/* syntax for constant ptx expressions */

/* BEGIN DUP */
u2 ::= '.u2'
u4 ::= '.u4'
u8 ::= '.u8'
u16 ::= '.u16'
u32 ::= '.u32'
u64 ::= '.u64'

s2 ::= '.s2'
s4 ::= '.s4'
s8 ::= '.s8'
s16 ::= '.s16'
s32 ::= '.s32'
s64 ::= '.s64'

b1 ::= '.b1'
b8 ::= '.b8'
b16 ::= '.b16'
b32 ::= '.b32'
b64 ::= '.b64'

f16 ::= '.f16'
f16x2 ::= '.f16x2'

f32 ::= '.f32'
f64 ::= '.f64'
pred ::= '.pred'

binary ::= b16 | b32 | b64
unsigned ::= u16 | u32 | u64
signed ::= s16 | s32 | s64
float ::= f32 | f64

signed_unsigned ::= signed | unsigned

/* these are possible types instruction, used to create PTX_TYPES in ptxgen/gentests.py */
/* TODO: matrix types */
ptx_types ::= binary | b1 | b8 | signed | s2 | s4 | s8 | unsigned | u2 | u4 | u8 | float | f16 | f16x2 | pred | '.ccregister' | '.texref' | '.surfref'
ptx_vector ::= '.v2' | '.v4'

/* END DUP */


HEX_LITERAL ::= '__external__'
OCT_LITERAL ::= '__external__'
BIN_LITERAL ::= '__external__'
DEC_LITERAL ::= '__external__'
FLTX_LITERAL ::= '__external__'
DBLX_LITERAL ::= '__external__'
DBL_LITERAL1 ::= '__external__'
DBL_LITERAL2 ::= '__external__'
DBL_LITERAL3 ::= '__external__'

ce_int_literal ::= HEX_LITERAL | OCT_LITERAL | BIN_LITERAL | DEC_LITERAL

/* a FLTX_LITERAL cannot occur in a constant expression */
ce_flt_literal ::= FLTX_LITERAL | DBLX_LITERAL

/* DBL_LITERAL? taken from C spec  */
/* decimal + exponent */
/* decimal point + number + exponent */
/* decimal + decimal point */


ce_dbl_literal ::= DBLX_LITERAL | DBL_LITERAL1 | DBL_LITERAL2 | DBL_LITERAL3
ce_literal ::= ce_int_literal | ce_dbl_literal

/* surprisingly -(.s64)1 works for ptxas, must have used the same trick? */

ce_primary ::= '(' ( '.s64' | '.u64' ) ')' constexpr | '(' constexpr ')' | ce_literal

ce_unary_1 ::= ('+' | '-' | '!' | '~')* ce_primary
ce_unary_2 ::= ce_unary_1

ce_prod ::= (ce_prod ('*' | '%' | '/'))? ce_unary_2

ce_sum ::= (ce_sum ('+' | '-'))? ce_prod

ce_shifts ::= (ce_shifts ('<<' | '>>'))? ce_sum

ce_cmp ::= (ce_cmp ('<' | '>' | '<=' | '>='))? ce_shifts

ce_eq ::= (ce_eq ('==' | '!='))? ce_cmp

ce_band ::= (ce_band '&')? ce_eq

ce_bxor ::= (ce_bxor '^')? ce_band

ce_bor ::= (ce_bor '|')? ce_bxor

ce_land ::= (ce_land '&&')? ce_bor

ce_lor ::= (ce_lor '||')? ce_land

ce_ternary ::= ce_ternary '?' ce_ternary ':' ce_ternary | ce_lor

constexpr ::= ce_ternary


/* === */
ID ::= '__external__'
label ::= ID ':'
predicate ::= '@' '!'? ID

addr_operand ::= '[' ID ('+' ce_int_literal )? ']'

array_index_calc ::= ID ('+' | '-') constexpr
array_index ::= '[' (ce_int_literal | ID | array_index_calc) ']'
array_operand ::= ID array_index+

/* TODO: test the nesting of these operators */
vector_operand ::= '{' ID (',' ID)* '}'
vector_suffixes ::= '.x' | '.y' | '.z' | '.w' | '.r' | '.g' | '.b' | '.a'
vector_extract ::= ID vector_suffixes

args ::= constexpr | ID | addr_operand | array_operand | vector_operand | vector_extract
arg_list ::= (args (',' args)*)?

/* ptxas accepts 32U and 64U */
address_size_dir ::= '.address_size' DEC_LITERAL

target_string ::= 'sm_70' | 'sm_72' | 'sm_75' | 'sm_60' | 'sm_61' | 'sm_62' | 'sm_50' | 'sm_52' | 'sm_53' | 'sm_30' | 'sm_32' | 'sm_35' | 'sm_37' | 'sm_20' | 'sm_10' | 'sm_11' | 'sm_12' | 'sm_13' | 'texmode_unified' | 'texmode_independent' | 'debug' | 'map_f64_to_f32'

target_list ::= ID (',' ID)*
target_dir ::= '.target' target_list address_size_dir?

/* NOTE: this rejigs ptx65_opcodse.txt */
state_spaces ::= '.reg' | '.sreg' | '.const' | '.global' | '.local' | '.param' | '.shared' | '.tex'
/* TODO: only const, global and .tex are initializable */

/* TODO: N => DEC_LITERAL only? */
ptr_dir ::= '.ptr' state_spaces '.align' DEC_LITERAL

generic_var ::= 'generic' '(' ID ')'
addr_expr ::= (generic_var | ID) '+' constexpr

/* TODO: array variable declarations */
array_decl ::= ID ('[' ce_int_literal? ']')+
var_parametric ::= ID '<' ce_int_literal '>'
varname ::= ID | array_decl | var_parametric

array_elem ::= scalar_init | array_init
array_elem_list ::= array_elem (',' array_elem)*
array_init ::= '{' array_elem_list '}'
scalar_init ::= constexpr | addr_expr
varinitializer ::= '=' (scalar_init | array_init)
attribute_spec ::= '.managed'
attribute_spec_list ::= attribute_spec (',' attribute_spec)*
attribute_dir ::= '.attribute' '(' attribute_spec_list ')'
align_dir ::= '.align' ce_int_literal
varinit_list ::= varname varinitializer? (',' varinit_list)*
var_decl ::= state_spaces align_dir? ptx_vector? ptx_types varinit_list
var_decl_stmt ::= var_decl ';'

param_state_spaces ::= '.param' | '.reg'
param_decl ::= param_state_spaces align_dir? ptx_vector? ptx_types varname
param_list ::= param_decl (',' param_decl)*
param_spec ::= '(' param_list? ')'

block_stmt ::= statement | var_decl_stmt | block
block ::= '{' block_stmt* '}'

func_body ::= block?
func ::= '.func' param_spec? ID param_spec? '.noreturn'? func_body

/* see the example of .entry cta_fft, but ptxas complains if two entry statements follow each other without a {} */
/* TODO: pragmas and performance-tuning directives */
entry ::= '.entry' ID param_spec? block

linker_dir ::= '.extern' | '.visible' | '.weak' | '.common'

linker_identifier ::= entry  | func | var_decl_stmt
linker_stmt ::= linker_dir linker_identifier

opcode ::= 'add' '.f32' | 'ld' '.param' '.u64' | 'cvta' '.to' '.global' '.u64' | 'ret' | 'ld' '.v2' '.b8' | 'st' '.global' '.u8' | 'cvt' '.u32' '.u8'

statement ::= label? predicate? opcode arg_list ';'

start ::= target_dir (statement | var_decl_stmt | entry | func | linker_stmt )*
